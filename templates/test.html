<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Multipart Upload Demo</title>
</head>
<body>

<h2>Multipart Upload Demo (Parallel, Min 10MB Chunks)</h2>

<input type="file" id="fileInput" />
<button onclick="startMultipartUpload()">Upload</button>

<pre id="log"></pre>

<script>
const BASE = "https://test.bowlersnetwork.com/api";
const BUCKET = "cdn";
const TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzY2Nzg3ODkyLCJpYXQiOjE3NjQxOTU4OTIsImp0aSI6IjU0MWVmNmM5MjVmODQ0YmM4MTgyYWIzZTVmNzdjZjUwIiwidXNlcl9pZCI6NTR9.6-3LQVDtOzXaO_gYERu4mrrnuTKSRyuqsSsId0xCMMk";

const MIN_CHUNK = 10 * 1024 * 1024; // 10MB

function log(msg) {
  document.getElementById("log").textContent += msg + "\n";
}

async function apiPOST(url, body) {
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${TOKEN}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
  return res.json();
}

function sliceFileIntoChunks(file) {
  const chunks = [];
  let offset = 0;

  while ((file.size - offset) > MIN_CHUNK) {
    chunks.push(file.slice(offset, offset + MIN_CHUNK));
    offset += MIN_CHUNK;
  }

  // Last smaller chunk (â‰¤ 10MB allowed)
  chunks.push(file.slice(offset, file.size));

  return chunks;
}


async function startMultipartUpload() {
  const file = document.getElementById("fileInput").files[0];
  if (!file) return alert("Select a file first");

  log(`Selected file: ${file.name} (${(file.size/1024/1024).toFixed(2)}MB)`);

  // 1) Initiate multipart upload
  const initRes = await apiPOST(`${BASE}/cloud/upload/multipart/requests/initiate`, {
    file_name: file.name,
    bucket: BUCKET
  });

  if (initRes.errors) {
    log("INIT ERROR: " + JSON.stringify(initRes.errors));
    return;
  }

  const key = initRes.key;
  const upload_id = initRes.upload_id;

  log(`Key: ${key}`);
  log(`Upload ID: ${upload_id}`);

  // 2) Create chunks
  const chunks = sliceFileIntoChunks(file);
  log(`Created ${chunks.length} chunks`);

  // 3) Upload chunks in parallel
  const uploadPromises = chunks.map((chunk, index) => uploadChunk(chunk, index + 1, key, upload_id));

  const parts = await Promise.all(uploadPromises);

  // 4) Filter failures
  const successfulParts = parts.filter(p => p && p.ETag);
  if (successfulParts.length !== parts.length) {
    log("Some parts failed. Aborting multipart upload.");
    return;
  }

  // 5) Complete upload
  log("Completing multipart upload...");
  const completeRes = await apiPOST(`${BASE}/cloud/upload/multipart/requests/complete`, {
    bucket: BUCKET,
    params: {
      key,
      upload_id,
      parts: successfulParts
    }
  });

  log("Upload complete!");
  log(JSON.stringify(completeRes, null, 2));
}

async function uploadChunk(chunk, partNumber, key, upload_id) {
  log(`Requesting presigned URL for part ${partNumber}...`);

  const presignRes = await apiPOST(`${BASE}/cloud/upload/multipart/requests/presigned-url`, {
    bucket: BUCKET,
    params: { key, upload_id, part_number: partNumber }
  });

  if (presignRes.errors) {
    log(`Presign ERROR part ${partNumber}: ${JSON.stringify(presignRes.errors)}`);
    return null;
  }

  const url = presignRes.presigned_url;
  log(`Uploading part ${partNumber} (${(chunk.size/1024/1024).toFixed(2)}MB)...`);

  const putRes = await fetch(url, {
    method: "PUT",
    body: chunk
  });

  const etag = putRes.headers.get("ETag");

  if (!putRes.ok || !etag) {
    log(`UPLOAD ERROR part ${partNumber}: ETag missing`);
    return null;
  }

  log(`Part ${partNumber} uploaded (ETag: ${etag})`);

  return {
    PartNumber: partNumber,
    ETag: etag
  };
}
</script>

</body>
</html>
